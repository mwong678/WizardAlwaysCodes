"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var express = require("express");
var msgpack = require("msgpack-lite");
var memshared = require("memshared");
var uws_1 = require("uws");
var Protocol_1 = require("../Protocol");
var _1 = require("../");
var Worker_1 = require("../cluster/Worker");
var app = new express();
var server = app.listen(0, "localhost");
var wss = new uws_1.Server({ server: server });
wss.on('connection', onConnect);
//
// Listen to "redirect" messages from main process, to redirect the connection
// to match-making process.
//
var callbacks = {};
process.on('message', function (message, socket) {
    console.log("matchmaking received message: ", message[0]);
    if (message[0] === Protocol_1.Protocol.PASS_WEBSOCKET) {
        Worker_1.handleUpgrade(wss, socket, message);
        return;
    }
    else if (Array.isArray(message) && callbacks[message[0]]) {
        var callback = callbacks[message[0]];
        callback(message[1]);
        return;
    }
});
// Process spawned successfully!
console.log("MatchMaking process spawned with pid", process.pid);
function onConnect(client) {
    client.id = _1.generateId();
    console.log("WebSocketServer: onConnect", client.id);
    client.on('message', function (message) {
        // try to decode message received from client
        try {
            message = msgpack.decode(Buffer.from(message));
        }
        catch (e) {
            console.error("Couldn't decode message:", message, e.stack);
            return;
        }
        if (message[0] !== Protocol_1.Protocol.JOIN_ROOM) {
            console.error("MatchMaking couldn't process message:", message);
            return;
        }
        var roomName = message[1];
        var joinOptions = message[2];
        // has room handler avaialble?
        memshared.lindex("handlers", roomName, function (err, index) {
            if (index === -1) {
                Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomName, "Error: no available handler for \"" + roomName + "\""]);
                return;
            }
            // retrieve active worker ids
            memshared.lrange("workerIds", 0, -1, function (err, workerIds) {
                // Request to join an existing sessions for requested handler
                memshared.smembers(roomName, function (err, availableWorkerIds) {
                    var numAvaialbleWorkers = availableWorkerIds.length;
                    console.log("numAvaialbleWorkers", numAvaialbleWorkers);
                    // No workers has an instance of the requested handler.
                    // Let's create an instance on a worker with fewer handler spawned.
                    if (numAvaialbleWorkers === 0) {
                        memshared.mget(availableWorkerIds, function (err, spawnedRooms) {
                            var selectedWorkerId = (spawnedRooms.length > 0)
                                ? workerIds[spawnedRooms.indexOf(Math.min.apply(Math, spawnedRooms))]
                                : workerIds[0];
                            callbacks[client.id] = handleResponse(client);
                            joinOptions.clientId = client.id;
                            // Send JOIN_ROOM command to selected worker process.
                            process.send([selectedWorkerId, Protocol_1.Protocol.CREATE_ROOM, roomName, joinOptions]);
                        });
                    }
                    else {
                        // Broadcast message and wait for the reply of every worker
                        console.log("broadcasting raw message to other processes", message);
                        process.send(message);
                    }
                });
            });
        });
    });
    client.on('error', function (e) {
        console.error("[ERROR]", client, e);
    });
}
function handleResponse(client) {
    return function (data) {
        console.log("handle response...", data);
        Protocol_1.send(client, data);
        if (data[0] !== Protocol_1.Protocol.JOIN_ERROR) {
            client.close();
        }
    };
}
